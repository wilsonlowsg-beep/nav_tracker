nique colours per user)
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Nav Tracker Map</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    body { margin:0; font-family: system-ui, -apple-system, Arial, sans-serif; }
    #map { position: fixed; left:0; top:0; right:320px; bottom:0; }
    #panel {
      position: fixed; top:0; right:0; bottom:0; width:320px;
      overflow:auto; background:#fff; border-left:1px solid #ddd; padding:12px;
    }
    .small { color:#666; font-size: 12px; }
    .row { border-bottom:1px solid #eee; padding:10px 0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; }
    .dot {
      display:inline-block; width:10px; height:10px; border-radius:50%;
      margin-right:8px; vertical-align:middle;
    }
    .btn { padding:8px 10px; border:1px solid #ddd; border-radius:10px; background:#fff; }
  </style>
</head>
<body>
  <div id="map"></div>

  <div id="panel">
    <h3>Events</h3>
    <div class="small">Auto-refresh every 3s</div>

    <div style="margin:10px 0;">
      <button class="btn" id="recenterBtn">Recenter</button>
    </div>

    <div class="small">Show users active within (seconds):</div>
    <input id="since" class="mono" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:10px;"
           value="{{ default_since_sec }}" />

    <div style="margin-top:12px;">
      <div id="status" class="small"></div>
    </div>

    <div id="list"></div>
  </div>

<script>
  // Deterministic color per user
  function hashToHue(str) {
    let h = 0;
    for (let i=0; i<str.length; i++) h = (h * 31 + str.charCodeAt(i)) >>> 0;
    return h % 360;
  }
  function colorForUser(u) {
    const hue = hashToHue(u || "anonymous");
    return `hsl(${hue}, 85%, 45%)`;
  }

  function makeDotIcon(color) {
    return L.divIcon({
      className: "",
      html: `<div style="
        width:16px;height:16px;border-radius:50%;
        background:${color};
        border:2px solid white;
        box-shadow:0 1px 6px rgba(0,0,0,.35);
      "></div>`,
      iconSize: [16,16],
      iconAnchor: [8,8],
    });
  }

  // Map init
  const map = L.map('map', { zoomControl: true });
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap'
  }).addTo(map);

  map.setView([1.3521, 103.8198], 12); // SG default

  const markers = {}; // user -> marker
  let firstFit = true;

  async function fetchJSON(path) {
    const res = await fetch(path, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.json();
  }

  function renderList(items) {
    const el = document.getElementById("list");
    el.innerHTML = "";
    items.forEach(p => {
      const c = colorForUser(p.user);
      const row = document.createElement("div");
      row.className = "row";
      row.innerHTML = `
        <div><span class="dot" style="background:${c}"></span><b>${p.user}</b></div>
        <div class="small">${p.ts || ""}</div>
        <div class="mono">lat ${p.lat ?? ""}, lng ${p.lng ?? ""}</div>
      `;
      el.appendChild(row);
    });
  }

  function updateMarkers(items) {
    const seen = new Set();

    items.forEach(p => {
      if (p.lat == null || p.lng == null) return;
      seen.add(p.user);

      const c = colorForUser(p.user);
      const icon = makeDotIcon(c);

      if (!markers[p.user]) {
        markers[p.user] = L.marker([p.lat, p.lng], { icon }).addTo(map);
      } else {
        markers[p.user].setLatLng([p.lat, p.lng]);
        markers[p.user].setIcon(icon);
      }

      markers[p.user].bindPopup(`<b>${p.user}</b><br>${p.ts}<br>±${Math.round(p.acc || 0)}m`);
    });

    // Remove users not in latest feed (so old traces "disappear" based on since_sec)
    Object.keys(markers).forEach(u => {
      if (!seen.has(u)) {
        map.removeLayer(markers[u]);
        delete markers[u];
      }
    });

    if (firstFit && items.length > 0) {
      const latlngs = items.filter(p=>p.lat!=null && p.lng!=null).map(p => [p.lat, p.lng]);
      if (latlngs.length) map.fitBounds(latlngs, { padding: [50,50] });
      firstFit = false;
    }
  }

  async function refresh() {
    const sinceSec = document.getElementById("since").value.trim() || "{{ default_since_sec }}";
    try {
      document.getElementById("status").textContent = "Refreshing…";
      const items = await fetchJSON(`/positions?since_sec=${encodeURIComponent(sinceSec)}`);
      renderList(items);
      updateMarkers(items);
      document.getElementById("status").textContent = `OK (${items.length} users)`;
    } catch (e) {
      document.getElementById("status").textContent = "Refresh failed: " + e.message;
    }
  }

  document.getElementById("recenterBtn").addEventListener("click", () => { firstFit = true; refresh(); });

  refresh();
  setInterval(refresh, 3000);
</script>
</body>
</html>